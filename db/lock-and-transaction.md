###1、并发读写问题
---
####1.1、问题描述
单号先读，修改后，写入库

####1.2、无@Transaction注解配置
autoCommit=true,每一条sql都会自动commit，没有事务隔离行为

####1.3、@Transaction=Connection.TRANSACTION_READ_COMMITTED
autoCommit=false,

MySQLTransactionRollbackException: Lock wait timeout exceeded; try restarting transaction

查看mysql隔离级别：select @@tx_isolation

###2、乐观锁或悲观所实现
（之所以以InnoDB为主介绍锁，是因为InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁）

所以解决办法为程序中加入悲观锁 或 乐观锁 机制。悲观锁采用的是 select ... for update，

事务A：  select ... for update，执行更新操作，
事务B：  select ... for update --阻塞
这时事务B读取操作将无法执行，只有当事务A的commit完成，事务B才可以继续执行，相当于采用串行一个个执行。

乐观锁常用的是版本控制或时间戳控制，

事务A：执行 此时版本为 1；执行完update ...set version=2 where version = 1;
事务B：执行 此时版本为 1；执行完update ...set version=2 where version = 1;
这时候事务B发现version=1已经不存在了，因为事务A首先执行完更新了数据库，把version字段设为了2，这样就会导致该事务提交失败，需要我们在程序中判断异常情况下如何继续操作。

###2、InnoDB引擎的锁机制

（之所以以InnoDB为主介绍锁，是因为InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁）

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

说明：

1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。

2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！。

###2、Mysql MVCC详解(http://blog.csdn.net/ai2713165/article/details/50488649)
Innodb为每行记录都实现了三个隐藏字段：
6字节的事务ID（DB_TRX_ID ）
7字节的回滚指针（DB_ROLL_PTR）
隐藏的ID

1. Innodb的事务相关概念
为了支持事务，Innbodb引入了下面几个概念：
redo log
redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作即可。当客户端执行每条SQL（更新语句）时，redo log会被首先写入log buffer；当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即Innodb的log文件。
undo log
与redo log相反，undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。
rollback segment
回滚段这个概念来自Oracle的事物模型，在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段。可以认为undo log和回滚段是同一意思。
锁
Innodb提供了基于行的锁，如果行的数量非常大，则在高并发下锁的数量也可能会比较大，据Innodb文档说，Innodb对锁进行了空间有效优化，即使并发量高也不会导致内存耗尽。
对行的锁有分两种：排他锁、共享锁。共享锁针对对，排他锁针对写，完全等同读写锁的概念。如果某个事务在更新某行（排他锁），则其他事物无论是读还是写本行都必须等待；如果某个事物读某行（共享锁），则其他读的事物无需等待，而写事物则需等待。通过共享锁，保证了多读之间的无等待性，但是锁的应用又依赖Mysql的事务隔离级别。
隔离级别
隔离级别用来限制事务直接的交互程度，目前有几个工业标准：
- READ_UNCOMMITTED：脏读
- READ_COMMITTED：读提交
- REPEATABLE_READ：重复读
- SERIALIZABLE：串行化
Innodb对四种类型都支持，脏读和串行化应用场景不多，读提交、重复读用的比较广泛，后面会介绍其实现方式。

3. 事务级别
众所周知地是更新（update、insert、delete）是一个事务过程，在Innodb中，查询也是一个事务，只读事务。当读写事务并发访问同一行数据时，能读到什么样的内容则依赖事务级别：
READ_UNCOMMITTED
读未提交时，读事务直接读取主记录，无论更新事务是否完成
READ_COMMITTED
读提交时，读事务每次都读取undo log中最近的版本，因此两次对同一字段的读可能读到不同的数据（幻读），但能保证每次都读到最新的数据。
REPEATABLE_READ
每次都读取指定的版本，这样保证不会产生幻读，但可能读不到最新的数据
SERIALIZABLE
锁表，读写相互阻塞，使用较少
读事务一般有SELECT语句触发，在Innodb中保证其非阻塞，但带FOR UPDATE的SELECT除外，带FOR UPDATE的SELECT会对行加排他锁，等待更新事务完成后读取其最新内容。就整个Innodb的设计目标来说，就是提供高效的、非阻塞的查询操作。

###3、乐观锁与悲观锁——解决并发问题

###3、悲观锁和乐观锁与数据库隔离级别的关系(http://www.cnblogs.com/0201zcr/p/4782283.html)
http://www.lai18.com/content/931835.html
**关系总结，事务隔离级别是并发控制的整体解决方案，其实际上是综合利用各种类型的锁和行版本控制，来解决并发问题。锁是数据库并发控制的内部机制，是基础。对用户来说，只有当事务隔离级别无法解决一些并发问题和需求时，才有必要在语句中手动设置锁。**

CAS
CAS其实应用挺广泛的，我们常常听到的悲观锁乐观锁的概念，乐观锁（无锁）指的就是CAS。这里只是简单说下在并发的应用，所谓的乐观并发策略，通俗的说，就是先进性操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就采取其他的补偿措施（最常见的补偿措施就是不断重试，治到成功为止，这里其实也就是自旋CAS的概念），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种操作也被称为非阻塞同步。而CAS这种乐观并发策略操作和冲突检测这两个步骤具备的原子性，是靠什么保证的呢？硬件，硬件保证了一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。
也许你会存在疑问，为什么这种无锁的方案一般会比直接加锁效率更高呢？这里其实涉及到线程的实现和线程的状态转换。实现线程主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。而Java的线程实现则依赖于平台使用的线程模型。至于状态转换，Java定义了6种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这6种状态分别是：新建、运行、无限期等待、限期等待、阻塞、结束。 Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于简单的同步块（被synchronized修饰的方法），状态转换消耗的时间可能比用户代码执行的时间还要长。所以出现了这种优化方案，在操作系统阻塞线程之间引入一段自旋过程或一直自旋直到成功为止。避免频繁的切入到核心态之中。
但是这种方案其实也并不完美，在这里就说下CAS实现原子操作的三大问题
ABA问题。因为CAS需要在操作值的时候，检查值有没有变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有变化，但是实际上发生变化了。ABA解决的思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用原来的互斥同步可能会比原子类更高效。
循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。所以说如果是长时间占用锁执行的程序，这种方案并不适用于此。
只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用自旋CAS来保证原子性，但是对多个共享变量的操作时，自旋CAS就无法保证操作的原子性，这个时候可以用锁。、
谈完了这两个概念，下面我们就来逐个分析这五部分的具体源码实现